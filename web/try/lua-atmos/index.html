<!DOCTYPE html>
<html>
<head>
    <title>lua-atmos - Browser</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
        }
        #code {
            width: 80ch;
            height: 16em;
            font-family: monospace;
            font-size: 14px;
            tab-size: 4;
        }
        #output {
            width: 80ch;
            border: 1px solid #ccc;
            padding: 8px;
            min-height: 4em;
            background: #f8f8f8;
        }
        button {
            font-size: 14px;
            padding: 4px 16px;
            margin: 4px 4px 4px 0;
        }
        #status {
            color: #888;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <h3>lua-atmos in the Browser</h3>
    <textarea id="code">local atmos = require "atmos"
local X = require "atmos.x"
local streams = require "streams"

print("lua-atmos loaded!")
</textarea>
    <br>
    <button id="run">Run</button>
    <span id="status"></span>
    <pre id="output"></pre>

<script type="text/lua" data-module="streams">
local M = {}

M.mt = {
    __call  = function (t) return t:f() end,
    __close = function (t) if t.clo then t:clo() end end,
    __index = M,
}

function M.is (s)
    return (getmetatable(s) == M.mt)
end

local function close_s (t)
    local _ <close> = t.s
end

-------------------------------------------------------------------------------
-- SOURCES
-------------------------------------------------------------------------------

function M.from (v, ...)
    local multi = (select('#',...) > 0)
    if multi then
        assert(type(v)=='number' or M.is(v))
    end

    if v==nil or type(v)=='number' then
        return M.fr_range(v, ...)
    elseif M.is(v) then
        return M.fr_streams(v, ...)
    elseif type(v) == 'table' then
        return M.fr_table(v)
    elseif type(v) == 'function' then
        return M.fr_function(v)
    elseif type(v) == 'coroutine' then
        return M.fr_coroutine(v)
    else
        return M.fr_const(v)
    end
end

-------------------------------------------------------------------------------

local function fr_const (t)
    return t.v
end

function M.fr_const (v)
    local t = {
        v = v,
        f = fr_const,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function fr_coroutine (t)
    return (function (ok, ...)
        assert(ok)
        if (... == nil) then
            return nil
        end
        return ...
    end)(coroutine.resume(t.co))
end

local function close (t)
    coroutine.close(t.co)
end

function M.fr_coroutine (co)
    local t = {
        co  = co,
        f   = fr_coroutine,
        clo = close,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

function M.fr_counter (i)
    return M.fr_range(i)
end

-------------------------------------------------------------------------------

function M.fr_function (f)
    local t = {
        f = f,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function fr_range (t)
    if t.b and t.a>t.b then
        return nil
    end
    local v = t.a
    t.a = t.a + 1
    return v
end

function M.fr_range (a, b)
    local t = {
        a = a or 1,
        b = b,
        f = fr_range,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

function M.fr_streams (...)
    local n = select('#', ...)
    assert(n >= 2)
    local s = select(1, ...)
    for i=2, n do
        s = s:seq(select(i, ...))
    end
    return s
end

-------------------------------------------------------------------------------

local function fr_table (t)
    if t.i > #t.t then
        return nil
    end
    local v = t.t[t.i]
    t.i = t.i + 1
    return v
end

function M.fr_table (t)
    local t = {
        t = t,
        i = 1,
        f = fr_table,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------
-- COMBINATORS
-------------------------------------------------------------------------------

local function empty (t)
    return nil
end

function M.empty ()
    local t = {
        f = empty,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function acc0 (t)
    if t.done then
        return nil
    end
    local cur = t.cur
    local v = t.s()
    if v == nil then
        t.done = true
    else
        t.cur = t.g(t.cur, v)
    end
    return cur
end

function M.acc0 (s, z, g)
    local t = {
        s    = s,
        g    = g,
        cur  = z,
        done = false,
        f    = acc0,
        clo  = close_s,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function acc1 (t)
    local v = t.s()
    if v == nil then
        return nil
    end
    t.cur = t.g(t.cur, v)
    return t.cur
end

function M.acc1 (s, g)
    local t = {
        s   = s,
        g   = g,
        cur = nil,
        f   = acc1,
        clo = close_s,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function filter (t)
    while true do
        local v = t.s()
        if v == nil then
            return nil
        end
        if t.g(v) then
            return v
        end
    end
end

function M.filter (s, g)
    local t = {
        s   = s,
        g   = g,
        f   = filter,
        clo = close_s,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function skip (t)
    while t.n > 0 do
        if t.s() == nil then
            return nil
        end
        t.n = t.n - 1
    end
    return t.s()
end

function M.skip (s, n)
    local t = {
        s   = s,
        n   = n or 1,
        f   = skip,
        clo = close_s,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function seq (t)
    local v = t.cur()
    if v == nil then
        if t.nxt == nil then
            return nil
        end
        t.cur = t.nxt
        t.nxt = nil
        v = t.cur()
    end
    return v
end

local function close (t)
    local _ <close> = t.cur
    local _ <close> = t.nxt
end

function M.seq (s1, s2)
    local t = {
        cur = s1,
        nxt = s2,
        f   = seq,
        clo = close,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function take (t)
    if t.i >= t.n then
        return nil
    end
    t.i = t.i + 1
    return t.s()
end

function M.take (s, n)
    local t = {
        s   = s,
        i   = 0,
        n   = n,
        f   = take,
        clo = close_s,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

local function tee2 (t)
    if #t.q1 == 0 then
        local v = t.s()
        if v ~= nil then
            table.insert(t.q1, v)
            table.insert(t.q2, v)
        end
    end
    if #t.q1 <= 0 then
        return nil
    end
    return table.remove(t.q1, 1)
end

function M.tee2 (s)
    local q1, q2 = {}, {}
    local t1 = {
        s   = s,
        q1  = q1,
        q2  = q2,
        f   = tee2,
        clo = close_s,
    }
    local t2 = {
        s   = s,
        q1  = q2,
        q2  = q1,
        f   = tee2,
        clo = close_s,
    }
    t1 = setmetatable(t1, M.mt)
    t2 = setmetatable(t2, M.mt)
    return t1, t2
end

function M.tee (s, n, ...)
    local fs = { n, ... }
    if n == nil then
        n = 2
        fs = nil
    elseif type(n) == 'number' then
        fs = nil
        assert(select('#',...) == 0)
    else
        n = #fs
        for _,f in ipairs(fs) do
            assert(type(f) == 'function')
        end
    end
    assert(n >= 1)
    local ss = { s }
    for i=2, n do
        local s1,s2 = M.tee2(ss[#ss])
        ss[#ss] = nil
        ss[#ss+1] = s1
        ss[#ss+1] = s2
    end

    if fs then
        for i,f in ipairs(fs) do
            ss[i] = f(ss[i])
        end
    end

    return table.unpack(ss)
end

-------------------------------------------------------------------------------

local function zip (t)
    local vs = {}
    for i,s in ipairs(t.ss) do
        local v = s()
        if v == nil then
            return nil
        end
        vs[i] = v
    end
    return vs
end

local function close (t)
    for _, s in ipairs(t.ss) do
        local _ <close> = s
    end
end

function M.zip (...)
    local t = {
        ss  = {...},
        f   = zip,
        clo = close,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------

function M.map (s, f)
    return M.acc1(s, function (_, v) return f(v) end)
end

function M.mapi (s, f)
    local i = 0
    return s:map(function (v)
        i = i + 1
        return f(i, v)
    end)
end

function M.max (s)
    return M.acc0(s, -math.huge, function(a,x) return math.max(a,x) end)
end

function M.min (s)
    return M.acc0(s, math.huge, function(a,x) return math.min(a,x) end)
end

function M.sum (s)
    return M.acc0(s, 0, function(a,x) return a+x end)
end

function M.table (s)
    return M.acc0(s, {}, function(a,v) a[#a+1]=v ; return a end)
end

function M.tap (s, f)
    return M.acc1(s, function (_, v)
        f(v)
        return v
    end)
end

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

local function xseq (t)
    if t.s == false then
        t.s = t.ss()
    end
    if t.s == nil then
        return nil
    end
    local v = t.s()
    while v == nil do
        t.s = t.ss()
        if t.s == nil then
            return nil
        end
        v = t.s()
    end
    return v
end

function M.xseq (ss)
    local t = {
        ss  = ss,
        s   = false,
        f   = xseq,
        clo = close_s,
    }
    return setmetatable(t, M.mt)
end

-------------------------------------------------------------------------------
-- SINKS
-------------------------------------------------------------------------------

function M.to_last (s)
    local s <close> = s
    local v = nil
    local x = s()
    while true do
        if x == nil then
            return v
        end
        v = x
        x = s()
    end
end

M.to = M.to_last

function M.to_first (s)
    return s()
end

-------------------------------------------------------------------------------

do
    function M.to_any (s, f)
        return (s:filter(f):to_first() ~= nil)
    end

    function M.to_some (s, f)
        return (s:filter(f):skip(1):to_first() ~= nil)
    end

    function M.to_all (s, f)
        return not (s:to_any(function(x) return not f(x) end))
    end

    function M.to_none (s, p)
        return not s:to_any(p)
    end
end

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

--[===[
function M.fr_const (v)
    return M.fr_consts(v):take(1)
end

local function distinct (t)
    local v = t.s()
    while true do
        if v == nil then
            return nil
        elseif not t.seen[v] then
            t.seen[v] = true
            return v
        end
        v = t.s()
    end
end

function M.distinct (s)
    local t = {
        s = s,
        seen = {},
        f = distinct,
    }
    return setmetatable(t, M.mt)
end

local function loop (t)
    local v = t.s()
    if v == nil then
        t.s = t.fs()
        v = t.s()
    end
    return v
end

function M.loop (fs)
    local t = {
        fs = fs,
        s  = fs(),
        f  = loop,
    }
    return setmetatable(t, M.mt)
end

function M.to_vector (s)
    return M.to_table(s)
end

local function tuple (t)
    return (function (...)
        if ... == nil then
            return nil
        end
        return { tag=t.tag, ... }
    end)(t.s())
end

function M.tuple (s, tag)
    local t = {
        s   = s,
        tag = tag,
        f   = tuple,
    }
    return setmetatable(t, M.mt)
end

function M.mul (s)
    return M.acc0(s, 1, function(a,x) return a*x end)
end

function M.sort (s, f)
    return s:map(function (t)
        table.sort(t, f)    -- TODO: insertion sort
        return t
    end)
end

function M.skip (s, n)
    return s:mapi(function(i, v)
        if i > n then
            return M.fr_consts(v):take(1)
        else
            return M.empty()
        end
    end):xseq()
end
]===]

return M
</script>

<script type="text/lua" data-module="atmos">
require "atmos.util"
local run = require "atmos.run"

local atmos = {
    close  = run.close,
    call   = run.call,
    status = run.status,
    env    = run.env,
}

_is_  = run.is
throw = run.throw
catch = run.catch
call  = run.call

defer = run.defer
tasks = run.tasks

function task (tra, ...)
    if tra == nil then
        return run.me()
    elseif type(tra) == 'boolean' then
        return run.task(debug.getinfo(2), tra, ...)
    else
        return run.task(debug.getinfo(2), false, tra, ...)
    end
end

function spawn_in (up, t, ...)
    return run.spawn(debug.getinfo(2), up, false, t, ...)
end

function spawn (tra, t, ...)
    if type(tra) == 'boolean' then
        return run.spawn(debug.getinfo(2), nil, tra, t, ...)
    else
        return run.spawn(debug.getinfo(2), nil, false, tra, t, ...)
    end
end

function emit_in (to, e, ...)
    return run.emit(true, to, e, ...)
end

function emit (e, ...)
    return run.emit(true, nil, e, ...)
end

await    = run.await
clock    = run.clock
_or_     = run._or_
_and_    = run._and_
toggle   = run.toggle
every    = run.every
par      = run.par
par_or   = run.par_or
par_and  = run.par_and
watching = run.watching

return atmos
</script>

<script type="text/lua" data-module="atmos.util">
function trim (s)
    return (s:gsub("^%s*",""):gsub("\n%s*","\n"):gsub("%s*$",""))
end

function assertn (n, cnd, err)
    if n > 0 then
        n = n + 1
    end
    if not cnd then
        error(err, n)
    end
    return cnd
end

function totable (...)
    local t = {}
    local n = select('#',...) / 2
    assert((n*2) == select('#',...))
    for i=1, n do
        t[select(i,...)] = select(i+n,...)
    end
    return t
end

function debug_getinfo (n)
    return debug.getinfo(n+1) or { short_src='?', currentline='?' }
end
</script>

<script type="text/lua" data-module="atmos.run">
local S = require "atmos.streams"
require "atmos.util"

local run = {}

local task_gc

local meta_defer = {
    __close = function (t) t.f() end
}

local function _next (s, i)
    if i == s.max then
        return nil
    else
        i = i + 1
        return i, s.ts._.dns[i]
    end
end
local function _ipairs (ts)
    ts._.ing = ts._.ing + 1
    local close = setmetatable({}, {
        __close = function ()
            ts._.ing = ts._.ing - 1
            task_gc(ts)
        end
    })
    return _next, {ts=ts,max=#ts._.dns}, 0, close
end

local meta_tasks; meta_tasks = {
    __close = function (ts)
        for _,dn in ipairs(ts._.dns) do
            getmetatable(dn).__close(dn)
        end
    end,
    __len = function (ts)
        return #ts._.dns
    end,
    __pairs = _ipairs,
}
local meta_task = {
    __close = function (t)
        for _,dn in ipairs(t._.dns) do
            getmetatable(dn).__close(dn)
        end
        local st = coroutine.status(t._.th)
        if st == 'suspended' then
            assert(coroutine.close(t._.th))
        elseif st ~= 'dead' then
            t._.status = 'aborted'
        end
    end
}

local TIME = 1

local TASKS = setmetatable({
    _ = {
        up  = nil,
        dns = {},
        pin = true,
        ing = 0,
        gc  = false,
        max = nil,
        cache = setmetatable({}, {__mode='k'}),
    }
}, meta_tasks)

-------------------------------------------------------------------------------

local function _me_ (tra, t)
    if t == TASKS then
        return nil
    elseif (getmetatable(t) == meta_tasks) or ((not tra) and t._.tra) then
        return _me_(tra, t._.up)
    else
        return t
    end
end

function run.me (tra)
    local th = coroutine.running()
    return th and TASKS._.cache[th] and _me_(tra, TASKS._.cache[th])
end

function run.is (v, x)
    if v == x then
        return true
    end
    local tp = type(v)
    local mt = getmetatable(v)
    if tp == x then
        return true
    elseif tp=='string' and type(x)=='string' then
        return (string.find(v, '^'..x..'%.') == 1)
    elseif mt==meta_task and x=='task' then
        return true
    elseif mt==meta_tasks and x=='tasks' then
        return true
    elseif tp=='table' and type(x)=='string' then
        return (string.find(v.tag or '', '^'..x) == 1)
    else
        return false
    end
end

function run.status (t)
    return coroutine.status(t._.th)
end

-------------------------------------------------------------------------------

local function task_result (t, ok, err)
    if ok then
        -- no error: continue normally
        if t._.status == 'aborted' then
            -- t aborted from outside
            -- close now and continue normally
            -- could not close before b/c t was running
            -- TODO: lua5.5
            assert(coroutine.close(t._.th))
        end
    else
        coroutine.close(t._.th) -- TODO: assert fails "tasks.lua: error 2"
        error(err, 0)
    end

    if coroutine.status(t._.th) == 'dead' then
        t.ret = err
        t._.up._.gc = true
        --if t._.status ~= 'aborted' then
            local up = _me_(false, t._.up)
            run.emit(false, up, t)
            if (getmetatable(t._.up) == meta_tasks) and (t._.up ~= TASKS) then
                local up = _me_(false, t._.up._.up)
                run.emit(false, up, t._.up, t)
            end
        --end
        meta_task.__close(t)
    end
end

task_gc = function (t)
    if t._.gc and t._.ing==0 then
        t._.gc = false
        for i=#t._.dns, 1, -1 do
            local s = t._.dns[i]
            if getmetatable(s)==meta_task and coroutine.status(s._.th)=='dead' then
                table.remove(t._.dns, i)
            end
        end
    end
end

---------------------------------------------------------------------------------
-------------------------------------------------------------------------------

local _env_ = {
    step  = nil,
    loop  = nil,
    stop  = nil,
    close = nil,
}

function run.env (e)
    _env_ = e
end

function run.close ()
    meta_tasks.__close(TASKS)
end

function run.defer (f)
    return setmetatable({f=f}, meta_defer)
end

local meta_throw = {}

local function trace ()
    local ret = {}
    local x = run.me(true)
    while x and x~=TASKS do
        ret[#ret+1] = {
            msg = (getmetatable(x)==meta_task and 'task') or 'tasks',
            dbg = x._.dbg,
        }
        x = x._.up
    end
    return ret
end

local function tothrow (dbg, ...)
    local err = {
        _ = {
            dbg = { file=dbg.short_src, line=dbg.currentline },
            pre = trace(),
            pos = {},
        },
        ...
    }
    return setmetatable(err, meta_throw)
end

function run.throw (...)
    return error(tothrow(debug_getinfo(2),...))
end

function run.catch (...)
    local cnd = { ... }
    local blk = table.remove(cnd, #cnd)
    return (function (ok, err, ...)
        if ok then
            return ok,err,...
        elseif getmetatable(err) == meta_throw then
            local X = cnd[1]
            if false then
            elseif X == false then
                error(err, 0)
            elseif X == true then
                return false, table.unpack(err)
            elseif type(X) == 'function' then
                return (function (ok, ...)
                    if ok then
                        return false, ...
                    else
                        error(err, 0)
                    end
                end)(X(table.unpack(err)))
            else
                for i=1, #cnd do
                    if not run.is(err[i],cnd[i]) then
                        error(err, 0)
                    end
                end
                return false, table.unpack(err)
            end
        else
             error(err, 0)
        end
    end)(pcall(blk))
end

local function flatten (err)
    local str = ""
    for i,e in ipairs(err) do
        if i > 1 then
            str = str .. ", "
        end
        str = str .. tostring(e) or ('('..type(e)..')')
    end
    local ret = "==> ERROR:\n"

    for i=#err._.pos, 1, -1 do
        local t = err._.pos[i]
        ret = ret .. " |  "
        for j=1, #t do
            local e = t[j]
            ret = ret .. e.dbg.file .. ":" .. e.dbg.line .. " (" .. e.msg.. ")"
            if j < #t then
                ret = ret .. " <- "
            end
        end
        ret = ret .. "\n"
    end

    ret = ret .. " v  " .. err._.dbg.file .. ":" .. err._.dbg.line .. " (throw)"
    for i=1, #err._.pre do
        local e = err._.pre[i]
        ret = ret .. " <- "
        ret = ret .. e.dbg.file .. ":" .. e.dbg.line .. " (" .. e.msg .. ')'
    end
    ret = ret .. "\n"

    ret = ret .. "==> " .. str .. '\n'
    return ret
end

local function xcall (dbg, stk, f, ...)
    return (function (ok, err, ...)
        if ok then
            return err, ...
        end

        if type(err)=='string' and string.match(err, '^==> ERROR:') then
            -- already flatten
            error(err, 0)
        end

        if stk then
            if (getmetatable(err) ~= meta_throw) then
                local file, line, msg = string.match(err, '(.-):(%d-): (.*)')
                err = {
                    _ = {
                        dbg = { file=file or '?', line=line or '?' },
                        pre = trace(),
                        pos = {},
                    },
                    msg or err
                }
                err = setmetatable(err, meta_throw)
            end
            if getmetatable(err) == meta_throw then
                local t = trace()
                err._.pos[#err._.pos+1] = t
                table.insert(t, 1, {
                    msg = stk,
                    dbg = { file=dbg.short_src, line=dbg.currentline },
                })
            end
        end
        if stk == "call" then
            err = flatten(err)
        end
        error(err, 0)

    end)(pcall(f, ...))
end

function run.call (body, ...)
    assertn(2, type(body) == 'function', "invalid call : expected body function")
    local body = function (...)
        return (function (...)
            if _env_.stop then
                _env_.stop()
            end
            return ...
        end)(body(...))
    end
    return xcall(debug_getinfo(2), "call", function (...)
        local _ <close> = run.defer(function ()
            if _env_.close then
                _env_.close()
            end
            run.close()
        end)
        local t <close> = run.spawn(debug_getinfo(4), nil, false, body, ...)
        if _env_.loop then
            _env_.loop()
        else
            while true do
                if coroutine.status(t._.th) == 'dead' then
                    break
                end
                if _env_.step() then
                    break
                end
            end
        end
        return t.ret
    end, ...)
end

-------------------------------------------------------------------------------

function run.tasks (max)
    local n = max and tonumber(max) or nil
    assertn(2, (not max) or n, "invalid tasks limit : expected number")
    local up = run.me(true) or TASKS
    local dbg = debug_getinfo(2)
    local ts = {
        _ = {
            up  = up,
            dns = {},
            pin = false,
            ing = 0,
            gc  = false,
            dbg = {file=dbg.short_src, line=dbg.currentline},
            ---
            max = n,
        }
    }
    up._.dns[#up._.dns+1] = ts
    setmetatable(ts, meta_tasks)
    return ts
end

function run.task (dbg, tra, f)
    assertn(3, type(f)=='function', "invalid task : expected function")
    local t = {
        _ = {
            up  = nil,
            dns = {},
            pin = false,
            ing = 0,
            gc  = false,
            dbg = {file=dbg.short_src, line=dbg.currentline},
            ---
            th  = coroutine.create(f),
            tra = tra,
            status = nil, -- aborted, toggled
            await = {
                time = 0,
            },
            ret = nil,
        }
    }
    TASKS._.cache[t._.th] = t
    setmetatable(t, meta_task)
    return t
end

function run.spawn (dbg, up, tra, t, ...)
    if type(t) == 'function' then
        t = run.task(dbg, tra, t)
        if t == nil then
            return nil
        else
            return run.spawn(dbg, up, tra, t, ...)
        end
    end
    assertn(2, getmetatable(t)==meta_task, "invalid spawn : expected task prototype")
    assertn(2, t._.tra == tra, "invalid spawn : transparent modifier mismatch")

    up = up or run.me(true) or TASKS
    if getmetatable(up) == meta_tasks then
        t.pin = true
    end
    if up._.max then
        local n = #up._.dns
        if n >= up._.max then
            for _,t in ipairs(up._.dns) do
                if coroutine.status(t._.th) == 'dead' then
                    n = n - 1
                end
            end
            if n >= up._.max then
                return nil
            end
        end
    end
    up._.dns[#up._.dns+1] = t
    t._.up = assert(t._.up==nil and up)

    task_result(t, coroutine.resume(t._.th, ...))
    return t
end

-------------------------------------------------------------------------------

local function check_task_ret (t)
    if t.tag == '_==_' then
        if (getmetatable(t[1]) == meta_task) and (coroutine.status(t[1]._.th) == 'dead') then
            return true, t[1].ret, t[1]
        else
            return false
        end
    elseif t.tag == '_or_' then
        for _,x in ipairs(t) do
            local chk,ret = check_task_ret(x)
            if chk then
                return chk, ret
            end
        end
        return false
    elseif t.tag == '_and_' then
        local rets = {}
        for i,x in ipairs(t) do
            local chk,ret = check_task_ret(x)
            if chk then
                t[i] = { tag='_ok_', ret }
                rets[#rets+1] = ret
            end
        end
        if #rets == #t then
            return true, rets
        else
            return false
        end
    else
        return false
    end
end

local function check_ret (awt, ...)
    -- awt = await pattern | ... = occurring event arguments
    local e = awt[1]
    local mta = getmetatable(awt)
    local mte = getmetatable(...)
    if awt.tag == '_or_' then
        for _, x in ipairs(awt) do
            local vs = { check_ret(x, ...) }
            if vs[1] then
                return table.unpack(vs)
            end
        end
        return false
    elseif awt.tag == '_and_' then
        for i, x in ipairs(awt) do
            local vs = { check_ret(x, ...) }
            if vs[1] then
                local t = (#vs>2 and {table.unpack(vs,2)}) or vs[2]
                awt[i] = { tag='_ok_', t }
            end
        end
        local ret = {}
        for _,x in ipairs(awt) do
            if x.tag == '_ok_' then
                ret[#ret+1] = x[1]
            else
                return false
            end
        end
        return true, table.unpack(ret)
    elseif mta and mta.__atmos then
        return mta.__atmos(awt, ...)
    elseif mte and mte.__atmos then
        return mte.__atmos(awt, ...)
    elseif awt.tag == 'boolean' then
        if e == false then
            -- never awakes
            return false
        elseif e == true then
            return true, ...
        else
            error "bug found : impossible case"
        end
    elseif awt.tag == '_==_' then
        for i,v in ipairs(awt) do
            if not _is_(select(i,...),v) then
                return false
            end
        end
        if getmetatable(e) == meta_task then
            return true, e.ret --, e
        elseif getmetatable(e) == meta_tasks then
            -- invert ts,t -> t,ts
            return true, select(2,...), select(1,...), select(3,...)
        else
            return true, ...
        end
    elseif awt.tag == 'function' then
        local es = { ... }
        return (function (v, ...)
            if select('#',...) == 0 then
                return v, table.unpack(es)
            else
                return v, ...
            end
        end)(e(...))
    else
        return false
    end
end

local function awake (err, ...)
    local me = assert(run.me(true))
    if err then
        error((...), 0)
    else
        local awt = me._.await
        return (function (ok, ...)
            if ok then
                return ...
            else
                return awake(coroutine.yield())
            end
        end)(check_ret(awt, ...))
    end
end

local function clock_to_ms (clk)
    return (clk.ms                         or 0) +
           (clk.s   and clk.s  *1000       or 0) +
           (clk.min and clk.min*1000*60    or 0) +
           (clk.h   and clk.h  *1000*60*60 or 0)
end

local meta_clock; meta_clock = {
    -- await(clock{ms=100})
    -- vs
    -- emit('clock',100)
    -- emit(clock{ms=100})
    __atmos = function (a, e, dt, now)
        local ma = getmetatable(a)
        local me = getmetatable(e)
        if (ma == meta_clock) and (e=='clock' or me==meta_clock) then
            if e == 'clock' then
                a.cur = a.cur - dt
                return (a.cur <= 0), 'clock', -a.cur, now
            else
                a.cur = a.cur - clock_to_ms(e)
                return (a.cur <= 0), 'clock', -a.cur, nil
            end
        else
            return false
        end
    end
}

local function await_to_table (e, ...)
    local T
    if type(e) == 'table' then
        if (getmetatable(e) == meta_task) or getmetatable(e) == meta_tasks then
            T = { tag='_==_', e,... }
        elseif S.is(e) then
            --error'TODO'
            T = { tag='_==_', spawn(function() return e() end),... }
        elseif e.tag=='_or_' or e.tag=='_and_' then
            T = e
            for i,v in ipairs(T) do
                T[i] = await_to_table(table.unpack(v))
            end
        else
            if e.tag == 'clock' then
                e.cur = clock_to_ms(e)
                T = e
            else
                T = { tag='_==_', e,... }
            end
        end
    elseif type(e) == 'function' then
        T = { tag='function', e,... }
    elseif type(e) == 'boolean' then
        T = { tag='boolean', e,... }
    else
        T = { tag='_==_', e,... }
    end
    T.time = TIME
    return T
end

function run.await (e, ...)
    -- await(stream)
    -- await { tag='clock' }
    -- await(f)     -- f(...)
    -- await(true/false)
    -- await(task)
    -- await(...)
    -- await(a _and_ b)

    local t = run.me(true)
    assertn(2, t, "invalid await : expected enclosing task", 2)
    assertn(2, e~=nil, "invalid await : expected event", 2)

    t._.await = await_to_table(e, ...)

    local chk,ret = check_task_ret(t._.await)
    if chk then
        return ret
    end

    return awake(coroutine.yield())
end

function run.clock (t)
    assertn(2, type(t)=='table', "invalid clock : expected table")
    t.tag = 'clock'
    return setmetatable(t, meta_clock)
end

function run._or_ (...)
    local t = {
        tag = '_or_',
        ...
    }
    for i,x in ipairs(t) do
        if type(x) == 'table' then
            if getmetatable(x)==meta_task or getmetatable(x)==meta_tasks or x.tag then
                t[i] = { x }
            end
        else
            t[i] = { x }
        end
    end
    return t
end

function run._and_ (...)
    local t = {
        tag = '_and_',
        ...
    }
    for i,x in ipairs(t) do
        if type(x) == 'table' then
            if getmetatable(x)==meta_task or getmetatable(x)==meta_tasks or x.tag then
                t[i] = { x }
            end
        else
            t[i] = { x }
        end
    end
    return t
end

-------------------------------------------------------------------------------

local function fto (me, to)
    if to == nil then
        to = 0
    elseif to == 'task' then
        to = 0
    elseif to == 'parent' then
        to = 1
    end

    if to == 'global' then
        to = TASKS
    elseif type(to) == 'number' then
        local n = tonumber(to)
        to = me or TASKS
        while n > 0 do
            to = to._.up
            assertn(3, to~=nil, "invalid emit : invalid target")
            n = n - 1
        end
    elseif getmetatable(to)==meta_task or getmetatable(to)==meta_tasks then
        to = to
    else
        error("invalid emit : invalid target", 3)
    end

    return to
end

local function emit (time, t, ...)
    local ok, err = true, nil

    if t._.status == 'toggled' then
        return ok, err
    end

    t._.ing = t._.ing + 1
    for i=1, #t._.dns do
        local dn = t._.dns[i]
        ok, err = pcall(emit, time, dn, ...)
        if not ok then
            break
        end
    end
    t._.ing = t._.ing - 1

    task_gc(t)

    if getmetatable(t) == meta_task then
        if not ok then
            if coroutine.status(t._.th) == 'suspended' then
                ok, err = coroutine.resume(t._.th, 'atm_error', err)
                if ok then
                    task_result(t, ok, err)
                end
            end
            assertn(0, ok, err) -- TODO: error in defer?
        else
            if (t._.await.time < time) and (coroutine.status(t._.th) == 'suspended') then
                task_result(t, coroutine.resume(t._.th, nil, ...))
            end
        end
    else
        assert(getmetatable(t) == meta_tasks)
        assertn(0, ok, err)
    end
end

function run.emit (stk, to, e, ...)
    TIME = TIME + 1
    local time = TIME
    local ret = xcall(debug_getinfo(2), stk and "emit", emit, time, fto(run.me(false),to), e, ...)
    local me = run.me(true)
    if me and me._.status=='aborted' then
        -- TODO: lua5.5
        coroutine.yield()   -- wait to be closed from outside
    end
    return ret
end

-------------------------------------------------------------------------------

function run.toggle (t, on)
    if type(t) == 'string' then
        local e, f = t, on
        assertn(2, type(f)=='function', "invalid toggle : expected task prototype")
        do
            local t <close> = run.spawn(debug_getinfo(2), nil, true, f)
            local _ <close> = run.spawn(debug_getinfo(2), nil, true, function ()
                while true do
                    run.await(e, false)
                    run.toggle(t, false)
                    run.await(e, true)
                    run.toggle(t, true)
                end
            end)
            return run.await(t)
        end
    end

    assertn(2, getmetatable(t)==meta_task or getmetatable(t)==meta_tasks,
        "invalid toggle : expected task")
    assertn(2, type(on) == 'boolean', "invalid toggle : expected bool argument")
    if on then
        assertn(2, t._.status=='toggled', "invalid toggle : expected toggled off task")
        t._.status = nil
    else
        assertn(2, t._.status==nil --[[and coroutine.status(t._.th)=='suspended']],
            "invalid toggle : expected awaiting task")
        t._.status = 'toggled'
    end
end

-------------------------------------------------------------------------------

function run.every (...)
    assertn(2, run.me(true), "invalid every : expected enclosing task")
    local t = { ... }
    local blk = table.remove(t, #t)
    while true do
        blk(run.await(table.unpack(t)))
    end
end

local meta_par = {
    __close = function (ts)
        for _, t in ipairs(ts) do
            meta_task.__close(t)
        end
    end
}

function run.par (...)
    assertn(2, run.me(true), "invalid par : expected enclosing task")
    local fs = { ... }
    local ts <close> = setmetatable({}, meta_par)
    for i,f in ipairs(fs) do
        assertn(2, type(f) == 'function', "invalid par : expected task prototype")
        ts[i] = run.spawn(debug_getinfo(2), nil, true, select(i,...))
    end
    run.await(false)
end

function run.par_or (...)
    assertn(2, run.me(true), "invalid par_or : expected enclosing task")
    local fs = { ... }
    local ts <close> = setmetatable({}, meta_par)
    for i,f in ipairs(fs) do
        assertn(2, type(f) == 'function', "invalid par_or : expected task prototype")
        ts[i] = run.spawn(debug_getinfo(2), nil, true, f)
    end
    return run.await(run._or_(table.unpack(ts)))
end

function run.par_and (...)
    assertn(2, run.me(true), "invalid par_or : expected enclosing task")
    local fs = { ... }
    local ts <close> = setmetatable({}, meta_par)
    for i,f in ipairs(fs) do
        assertn(2, type(f) == 'function', "invalid par_or : expected task prototype")
        ts[i] = run.spawn(debug_getinfo(2), nil, true, f)
    end
    return run.await(run._and_(table.unpack(ts)))
end

function run.watching (...)
    assertn(2, run.me(true), "invalid watching : expected enclosing task")
    local t = { ... }
    local f = table.remove(t, #t)
    assertn(2, type(f) == 'function', "invalid watching : expected task prototype")
    local spw <close> = run.spawn(debug_getinfo(2), nil, true, f)
    return run.await(run._or_({table.unpack(t)}, spw))
end

return run
</script>

<script type="text/lua" data-module="atmos.streams">
local S = require "streams"

local n = 0
local function N ()
    n = n + 1
    return 'atmos.streams.' .. n
end

local from = S.from

function S.from (v, ...)
    if _is_(v, 'clock') then
        return S.fr_await(v, ...)
    end
    return from(v, ...)
end

-------------------------------------------------------------------------------

local function fr_await (t)
    return await(table.unpack(t.args))
end

local function fr_spawn (t)
    local x <close> = spawn(t.T, table.unpack(t.args))
    return await(x) or false
end

function S.fr_await (...)
    local T = select(1, ...)
    local t
    if type(T) == 'function' then
        t = {
            T    = T,
            args = { select(2,...) },
            f    = fr_spawn,
        }
    else
        t = {
            args = { ... },
            f    = fr_await,
        }
    end
    return setmetatable(t, S.mt)
end

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

function S.emitter (s, tgt, as)
    if as == nil then
        tgt, as = nil, tgt
    end
    return s:tap(function (v) emit_in(tgt, as, v) end)
end

-------------------------------------------------------------------------------

function S.Debounce (n, src, fctl)
    while true do
        local e = await(src)
        catch('X', function()
            while true do
                e = par_or (
                    function()
                        return await(src)
                    end,
                    function()    -- bounced
                        local ctl <close> = fctl()
                        ctl()
                        throw 'X'                   -- debounced
                    end
                )
            end
        end)
        emit_in(1, n, e)
    end
end

local function debounce (t)
    local _,v = await(t.n)
    return v
end

local function close (t)
    local _ <close> = t.tsk
end

function S.debounce (src, fctl)
    local n = N()
    local t = {
        n   = n,
        tsk = spawn(S.Debounce, n, src, fctl),
        f   = debounce,
        clo = close,
    }
    return setmetatable(t, S.mt)
end

-------------------------------------------------------------------------------

function S.Buffer (n, src, ctl)
    local ctl <close> = ctl
    while true do
        local ret = {}
        catch('X', function()
            while true do
                ret[#ret+1] = par_or (
                    function ()
                        return await(src)   -- buffered
                    end,
                    function()
                        await(ctl)
                        throw 'X'           -- released
                    end
                )
            end
        end)
        emit_in(1, n, ret)
    end
end

local function buffer (t)
    local _,v = await(t.n)
    return v
end

local function close (t)
    local _ <close> = t.tsk
end

function S.buffer (src, ctl)
    local n = N()
    local t = {
        n   = n,
        tsk = spawn(S.Buffer, n, src, ctl),
        f   = buffer,
        clo = close,
    }
    return setmetatable(t, S.mt)
end

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

local function T (n, s)
    while true do
        local v = s()
        if v == nil then
            return
        end
        emit_in(3, n, v)
    end
end

local function TT (n, tsks, ss)
    local ss <close> = ss
    local tsks <close> = tsks
    while true do
        local s = ss()
        if s == nil then
            await(false)
        end
        spawn_in(tsks, T, n, s)
    end
end

local function clo_tsk (t)
    local _ <close> = t.tsk
end

local function clo_tsks (t)
    local _ <close> = t.tsks
end

-------------------------------------------------------------------------------

local function par (t)
    local _,v = await(t.n)
    return v
end

function S.par (...)
    local n = N()
    local tsks = tasks()
    for i=1, select('#',...) do
        local s = select(i, ...)
        spawn_in(tsks, T, n, s)
    end
    local t = {
        n    = n,
        tsks = tsks,
        f    = par,
        clo  = clo_tsks,
    }
    return setmetatable(t, S.mt)
end

function S.xpar (ss)
    local n = N()
    local tsks = tasks()
    local t = {
        n    = n,
        tsks = tsks,
        tsk  = spawn(TT, n, tsks, ss),
        f    = par,
        clo  = clo_tsk,
    }
    return setmetatable(t, S.mt)
end

-------------------------------------------------------------------------------

local function paror (t)
    local x,v = await(_or_(t.n,t.tsks))
    if v == t.tsks then
        return nil
    end
    return v
end

function S.paror (...)
    local n = N()
    local tsks = tasks()
    for i=1, select('#',...) do
        local s = select(i, ...)
        spawn_in(tsks, T, n, s)
    end
    local t = {
        n    = n,
        tsks = tsks,
        f    = paror,
        clo  = clo_tsks,
    }
    return setmetatable(t, S.mt)
end

function S.xparor (ss)
    local n = N()
    local tsks = tasks()
    local t = {
        n    = n,
        tsks = tsks,
        tsk  = spawn(TT, n, tsks, ss),
        f    = paror,
        clo  = clo_tsk,
    }
    return setmetatable(t, S.mt)
end

-------------------------------------------------------------------------------

return S
</script>

<script type="text/lua" data-module="atmos.x">
local M = {}

function M.tostring (v)
    if type(v) ~= 'table' then
        return tostring(v)
    else
        local fst = true
        local vs = ""
        local t = {}
        for k,x in pairs(v) do
            assert(type(k)=='number' or type(k)=='string')
            --if k ~= 'tag' then
                t[#t+1] = { k, x }
            --end
        end
        table.sort(t, function (x, y)
            local n1, n2 = tonumber(x[1]), tonumber(y[1])
            if n1 and n2 then
                return (n1 < n2)
            else
                return (tostring(x[1]) < tostring(y[1]))
            end
        end)
        local i = 1
        for _,kx in ipairs(t) do
            local k,x = table.unpack(kx)
            if not fst then
                vs = vs .. ', '
            end
            if tonumber(k) == i then
                i = i + 1
                vs = vs .. M.tostring(x)
            else
                vs = vs .. k .. '=' .. M.tostring(x)
            end
            fst = false
        end
        --local tag = v.tag and (':'..v.tag..' ') or ''
        return --[[tag ..]] "@{" .. vs .. "}"
    end
end

function M.print (...)
    local ret = {}
    for i=1, select('#', ...) do
        ret[#ret+1] = M.tostring(select(i, ...))
    end
    print(table.unpack(ret))
end

function M.copy (v)
    if type(v) ~= 'table' then
        return v
    end
    local ret = {}
    for k,x in pairs(v) do
        ret[k] = M.copy(x)
    end
    return ret
end

return M
</script>

<script type="text/lua" data-module="atmos.env.clock">
local atmos = require "atmos"

local M = {
    now = 0,
}

local old = math.floor(os.clock() * 1000)

function M.step ()
    local now = math.floor(os.clock() * 1000)
    if now > old then
        emit('clock', (now-old), now)
        M.now = now
        old = now
    end
end

M.env = {
    init = M.init,
    step = M.step,
}

atmos.env(M.env)

return M
</script>


    <script type="module">
    import { LuaFactory } from
        'https://cdn.jsdelivr.net/npm/wasmoon@1.16.0/+esm';

    const LUA_MODULES = {};
    document.querySelectorAll(
        'script[type="text/lua"]'
    ).forEach(el => {
        LUA_MODULES[el.dataset.module] =
            el.textContent;
    });

    const btn = document.getElementById('run');
    const codeEl = document.getElementById('code');
    const output = document.getElementById('output');
    const status = document.getElementById('status');

    status.textContent = 'Loading...';
    btn.disabled = true;

    const factory = new LuaFactory();
    const lua = await factory.createEngine();

    lua.global.set('print', (...args) => {
        output.textContent +=
            args.join('\t') + '\n';
    });

    lua.global.set('now_ms', () => {
        return Date.now();
    });

    for (const [name, src] of
        Object.entries(LUA_MODULES))
    {
        lua.global.set('_mod_name_', name);
        lua.global.set('_mod_src_', src);
        await lua.doString(
            'package.preload[_mod_name_]'
            + ' = assert(load(_mod_src_,'
            + ' "@" .. _mod_name_))'
        );
    }

    status.textContent = '';
    btn.disabled = false;

    btn.addEventListener('click', async () => {
        output.textContent = '';
        status.textContent = 'Running...';
        btn.disabled = true;

        try {
            await lua.doString(codeEl.value);
            status.textContent = 'Done.';

        } catch (e) {
            output.textContent +=
                'ERROR: ' + e.message + '\n';
            status.textContent = 'Error.';
        }

        btn.disabled = false;
    });
    </script>
</body>
</html>
